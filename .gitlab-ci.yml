image: docker:stable


variables:
  REGISTRY_IMAGE: registry.gitlab.com/finestructure/swiftpackageindex
  IMAGE_SHA: $REGISTRY_IMAGE:$CI_COMMIT_SHA
  IMAGE_TAG: $REGISTRY_IMAGE:$CI_COMMIT_TAG
  DOCKER_TLS_CERTDIR: "/certs"


services:
  - docker:stable-dind


before_script:
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY

    
stages:
  - build
  - deploy
  - smoke-test


# We build only on the PROD project's pipeline, because we can read the image
# for dev deployment. There is no need to build the images twice in parallel.
# The PROD projects registry already has a build history, so we keep pushing to it.
build-sha:  # full build when not a tag
  rules:
    - if: '$ENV == "prod" && $CI_COMMIT_TAG == null'
  stage: build
  tags:
    - ceres
  script:
    - echo 'let appVersion = "'${CI_COMMIT_TAG:-$CI_COMMIT_SHA}'"' > ./Sources/App/Core/AppVersion.swift
    - docker build -t $IMAGE_SHA .
    - docker push $IMAGE_SHA
    

build-tag:  # tag previously built docker image when a tag
  rules:
    - if: '$ENV == "prod" && $CI_COMMIT_TAG != null'
  stage: build
  tags:
    - ceres
  script:
    # re-tag image with tag name
    - docker pull $IMAGE_SHA
    - docker tag $IMAGE_SHA $IMAGE_TAG
    - docker push $IMAGE_TAG


.deploy-common: &deploy-common
  stage: deploy
  image: docker/compose:1.25.5
  script: |
    set -eu
    VERSION=${CI_COMMIT_TAG:-$CI_COMMIT_SHA}
    # install curl and set up alias to post deployment to rollbar
    apk add --no-cache curl
    rollbar() {
      curl -H "X-Rollbar-Access-Token: $ROLLBAR_TOKEN" -X POST --data '{"environment": "'"$ENV"'", "local_username": "CI", "revision": "'"$VERSION"'", "status": "'"$1"'"}' https://api.rollbar.com/api/1/deploy
    }
    # migrate
    echo Migrating database ...
    docker-compose up -d db
    echo Deploying with SITE_URL: ${SITE_URL} ...
    env VERSION=$VERSION docker-compose run migrate
    # deploy
    env VERSION=$VERSION docker-compose up -d
    if [[ $? == 0 ]]; then
      rollbar succeeded
    else
      rollbar failed
    fi
  
  
deploy prod:  # PROD: auto-deploy tags
  rules:
    - if: '$ENV == "prod" && $CI_COMMIT_TAG != null'
  tags:
    - spi-prod
  <<: *deploy-common
  
  
deploy dev:  # DEV: auto-deploy main
  rules:
    - if: '$ENV == "dev" && $CI_COMMIT_BRANCH == "main"'
  tags:
    - spi-dev
  <<: *deploy-common


deploy dev (ad hoc):  # DEV: deploy any revision manually
  rules:
    - if: '$ENV == "dev"'
      when: manual
  tags:
    - spi-dev
  <<: *deploy-common


smoke-test:
  stage: smoke-test
  only:
    - tags
    - schedules
  tags:
    - ceres
  script: |
    rester() {
      docker run --rm -t -e base_url="$SITE_URL" -v $PWD:/host -w /host finestructure/rester:0.7.2 "$1"
    }
    echo Testing with SITE_URL: ${SITE_URL}
    rester restfiles/smoke-test.restfile
    rester restfiles/active-packages-test.restfile


.backup-common: &backup-common
  stage: build
  tags:
    - ceres
  script: |
    FILENAME=spi_prod_$(date "+%Y-%m-%dT%H:%M:%S").dump
    echo Backing up database to file ${FILENAME}
    echo Note: This requires the appropriate SSH tunnel to be active on the runner
    env PGPASSWORD=${DATABASE_PASSWORD} pg_dump --no-owner -Fc -h localhost -p 7432 -U spi_prod spi_prod > ${FILENAME}
    echo "Moving backup file to ${DB_BACKUP_DIR}"
    mv ${FILENAME} ${DB_BACKUP_DIR}


db-backup (scheduled):  # PROD: auto-backup on schedule
  rules:
    - if: '$ENV == "prod" && $CI_PIPELINE_SOURCE == "schedule"'
  <<: *backup-common


db-backup (manual):     # PROD: allow manual backup any time
  rules:
    - if: '$ENV == "prod"'
      when: manual
  <<: *backup-common
