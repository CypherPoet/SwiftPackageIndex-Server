image: docker:stable


variables:
  REGISTRY_IMAGE: registry.gitlab.com/finestructure/swiftpackageindex
  DOCKER_TLS_CERTDIR: "/certs"


services:
  - docker:stable-dind


before_script:
  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY


stages:
  - build
  - deploy
  - smoke-test


# We build only on the PROD project's pipeline, because we can read the image
# for dev deployment. There is no need to build the images twice in parallel.
# The PROD projects registry already has a build history, so we keep pushing to it.
build:
  rules:
    - if: '$ENV == "prod"'
  stage: build
  tags:
    - ceres
  script: |
    VERSION=${CI_COMMIT_TAG:-$CI_COMMIT_SHA}
    echo 'let appVersion: String? = "'${VERSION}'"' > ./Sources/App/Core/AppVersion.swift

    docker run --rm -v $PWD:/host -w /host --entrypoint sh node:15.8-alpine /usr/local/bin/yarn && /usr/local/bin/yarn build
    docker build -t $REGISTRY_IMAGE:$VERSION .

    retries=3
    until docker push $REGISTRY_IMAGE:$VERSION ; do
      [[ $retries -eq 0 ]] && echo "docker push failed" && exit 1
      sleep 5
      echo Retrying ...
      echo $((retries--)) retries left
    done


.deploy-common: &deploy-common
  stage: deploy
  image: docker/compose:1.25.5
  script: |
    set -eu
    VERSION=${CI_COMMIT_TAG:-$CI_COMMIT_SHA}
    # install curl and set up alias to post deployment to rollbar
    apk add --no-cache curl
    rollbar() {
      curl -H "X-Rollbar-Access-Token: $ROLLBAR_TOKEN" -X POST --data '{"environment": "'"$ENV"'", "local_username": "CI", "revision": "'"$VERSION"'", "status": "'"$1"'"}' https://api.rollbar.com/api/1/deploy
    }
    telegram() {
      curl -s -X POST https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage -d chat_id=${TELEGRAM_CHAT_ID} -d text="$1"
    }

    # pull image (retry for up to 30 minutes to allow builds on another pipeline to complete)
    echo Pulling image ...
    retries=180
    until docker pull $REGISTRY_IMAGE:$VERSION; do
      [[ $retries -eq 0 ]] && echo "docker pull failed" && exit 1
      sleep 10
      echo Retrying ...
      echo $((retries--)) retries left
    done

    echo Migrating database ...
    docker-compose up -d db  # ensure db is up
    env VERSION=$VERSION docker-compose run migrate

    echo Deploying VERSION $VERSION with SITE_URL: ${SITE_URL} ...
    telegram "ðŸš§ deploying version $VERSION ..."
    env VERSION=$VERSION docker-compose up --build -d
    if [[ $? == 0 ]]; then
      telegram "âœ… deployed version $VERSION"
      retries=5
      until rollbar succeeded ; do
        sleep 5
        echo Retrying ...
        echo $((retries--)) retries left
      done
    else
      telegram "ðŸ›‘ failed to deploy version $VERSION"
      retries=5
      until rollbar failed ; do
        sleep 5
        echo Retrying ...
        echo $((retries--)) retries left
      done
    fi
  
  
deploy prod:  # PROD: auto-deploy tags
  rules:
    - if: '$ENV == "prod" && $CI_COMMIT_TAG != null'
  tags:
    - spi-prod
  <<: *deploy-common



# TODO: consolidate with prod deployment once we've moved both envs
.deploy-common-dev: &deploy-common-dev
  stage: deploy
  image: docker
  script: |
    set -eu
    VERSION=${CI_COMMIT_TAG:-$CI_COMMIT_SHA}

    rollbar() {
      curl -H "X-Rollbar-Access-Token: $ROLLBAR_TOKEN" -X POST --data '{"environment": "'"$ENV"'", "local_username": "CI", "revision": "'"$VERSION"'", "status": "'"$1"'"}' https://api.rollbar.com/api/1/deploy
    }
    telegram() {
      curl -s -X POST https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage -d chat_id=${TELEGRAM_CHAT_ID} -d text="$1"
    }
    function get_version {
        url=$1
        set +e  # don't fail if curl sends garbage to jq
        DEPLOYED_VERSION=$(curl -s $url | jq -r '.version' 2> /dev/null)
        if [ $? -ne 0 ]; then DEPLOYED_VERSION="none"; fi
        set -e
        echo "$DEPLOYED_VERSION"
    }

    # pull image (retry for up to 30 minutes to allow builds on another pipeline to complete)
    echo Pulling image ...
    retries=180
    until docker pull $REGISTRY_IMAGE:$VERSION; do
      [[ $retries -eq 0 ]] && echo "docker pull failed" && exit 1
      sleep 10
      echo Retrying ...
      echo $((retries--)) retries left
    done

    echo Deploying VERSION $VERSION with SITE_URL: ${SITE_URL} ...
    telegram "ðŸš§ deploying version $VERSION ..."

    env VERSION=$VERSION \
      docker stack deploy --with-registry-auth -c app.yml app

    docker stack deploy --with-registry-auth -c mon.yml mon

    # poll for new version to be available
    ATTEMPTS=120
    for i in $(seq 1 $ATTEMPTS); do
        echo "Waiting for $VERSION to be active ($i)"
        sleep 2
        DEPLOYED_VERSION=$(get_version $SITE_URL/api/version)
        echo "DEPLOYED_VERSION $DEPLOYED_VERSION"
        if [[ "$DEPLOYED_VERSION" == "$VERSION" ]]; then break; fi
    done

    # wait for server to be fully available before reporting result
    SVC=app_server
    ATTEMPTS=120
    for i in $(seq 1 $ATTEMPTS); do
        echo "Waiting for all replicas to be available ($i)"
        sleep 2
        DEPLOYED=$(docker service ls -f "Name=${SVC}" --format "{{.Replicas}}")
        echo "DEPLOYED $DEPLOYED"
        IFS='/' read -ra COUNT <<< "$DEPLOYED"
        if [[ "${COUNT[0]}" == "${COUNT[1]}" ]]; then break; fi
    done

    if [[ "$DEPLOYED_VERSION" == "$VERSION" && "${COUNT[0]}" == "${COUNT[1]}" ]]; then
      telegram "âœ… deployed version $VERSION"
      retries=5
      until rollbar succeeded ; do
        sleep 5
        echo Retrying ...
        echo $((retries--)) retries left
      done
    else
      telegram "ðŸ›‘ failed to deploy version $VERSION"
      retries=5
      until rollbar failed ; do
        sleep 5
        echo Retrying ...
        echo $((retries--)) retries left
      done
    fi


deploy dev:  # DEV: auto-deploy main
  rules:
    - if: '$ENV == "dev" && $CI_COMMIT_BRANCH == "main"'
    - if: '$ENV == "dev" && $CI_COMMIT_TAG != null'
  tags:
    - spi-d1
  <<: *deploy-common-dev


deploy dev (ad hoc):  # DEV: deploy any revision manually
  rules:
    - if: '$ENV == "dev"'
      when: manual
  tags:
    - spi-d1
  <<: *deploy-common-dev


smoke-test:
  rules:
    - if: '$ENV == "prod" && $CI_COMMIT_TAG != null'
    - if: '$ENV == "prod" && $CI_PIPELINE_SOURCE == "schedule"'
    - if: '$ENV == "dev"'
  stage: smoke-test
  tags:
    - ceres
  script: |
    rester() {
      docker run --rm -t -e base_url="$SITE_URL" -v $PWD:/host -w /host finestructure/rester:0.7.2 "$1"
    }
    echo Testing with SITE_URL: ${SITE_URL}
    rester restfiles/smoke-test.restfile
    echo "Running full suite of package tests ..."
    docker run finestructure/rester-sitemap:1.0.0 ${SITE_URL}/sitemap.xml > all-packages.restfile
    rester all-packages.restfile


.backup-common: &backup-common
  stage: build
  tags:
    - spi-prod-backup
  script: |
    TARFILE=spi_${ENV}_$(date +%Y-%m-%d).tgz
    DUMPFILE=$(basename $TARFILE .tgz).dump
    ./scripts/db_backup.sh $TARFILE $DUMPFILE
    ./scripts/convert_to_db_dump.sh $TARFILE $DUMPFILE
    # copy file to S3
    S3_BACKUP_DIR=/Users/spi/Desktop/spi-db-backups
    # mount s3fs just in case (ignoring errors when it's already mounted)
    s3fs spi-db-backups ${S3_BACKUP_DIR} -o passwd_file=/Users/spi/.passwd-s3fs || true
    cp $DB_BACKUP_DIR/$DUMPFILE ${S3_BACKUP_DIR}/

db-backup (scheduled):  # PROD: auto-backup on schedule
  rules:
    - if: '$ENV == "prod" && $CI_PIPELINE_SOURCE == "schedule"'
  <<: *backup-common


db-backup (manual):     # PROD: allow manual backup any time
  rules:
    - if: '$ENV == "prod"'
      when: manual
  allow_failure: true
  <<: *backup-common
